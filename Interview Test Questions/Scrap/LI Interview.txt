
/*
 * Returns true if the input string is a number and false otherwise
 */
 
public boolean isNumber(String toTest)
{
    char[] ch = toTest.ToCharArray();
    int counter = 0, oneDecimal = 0, oneMinus = 0;
    for(int i = 0; i < toTest.length(); i++) {
        if (Char.IsDigit(ch)) {
            counter++;
        }
        if (ch == '-' && i == 0) oneMinus++;
        else if (ch == '-') oneMinus = 2;
        if (ch == '.') oneDecimal++;
    }
    return counter == toTest.Length() && oneDecimal < 2 && oneMinus < 2;
}

static void main (string[] args) {
    Assert.IsTrue(isNumber("1"));
    Assert.IsTrue(isNumber("-1"));
    Assert.IsTrue(isNumber("1.2"));
    Assert.IsFalse(isNumber("1.1.2"));
    Assert.IsFalse(isNumber("-1-1"));
}


----


public interface iIntervals {
 
    /**
     * Adds an interval [from, to) into internal structure.
     */
    void addInterval(int from, int to);
 
 
    /**
     * Returns a total length covered by the added intervals.
     * If several intervals intersect, the intersection should be counted only once.
     * Example:
     *
     * addInterval(3, 6)
     * addInterval(8, 9)
     * addInterval(1, 5)
     *
     * getTotalCoveredLength() -> 6
     * I.e. [1,5) and [3,6) intersect and give a total covered interval [1,6).
     * [1,6) and [8,9) don't intersect, so the total covered length is a sum of both intervals, that is 5+1=6.
     *
     *           _________
     *                          ___
     *     ____________
     *
     * 0  1  2  3  4  5  6  7  8  9  10
     *
     */
    int getTotalCoveredLength();
}

public class Intervals : iIntervals {

    List<Tuple<int,int>> storage = new List<Tuple<int, int>>();

    void addInterval(int from, int to) {
        storage.Add(Tuple.Create(from, to));
    }
    
    int getTotalcoveredLength() {
        List<Tuple<int, int>> temp = new List<Tuple<int, int>>();
        for (int i = 0; i < storage.Count; i++) {
            if (i+1 < storage.Count) {
                temp.Insert(isOverlap(storage[i], storage[i+1]));
            }
        }
        
    }
    // 1,3
    // 2,4
    //     1-4
    // 2,4
    // 5,8
    
    private List<Tuple<int, int>> isOverlap(Tuple<int, int> one, Tuple<int, int> two) {
        List<Tuple<int, int>> returnVal = new List<Tuple<int, int>>();
        /*if (one.First > two.First && one.First < two.Second) { 
            if (one.Second < two.Second && one.Second > two.First) {
                returnVal.Add(Tuple.Create(two.First, two.Second));
            } else if (one.Second > two.Second) {
                returnVal.Add(Tuple.Create(two.First, one.Second));
            }
        } else if (one.Second > two.First && one.Second < two.Second) {
            if (one.First < two.first) {
                
            } else if (one.First < two) { 
                
            }
        } */
        
        if (one.first < two.First && one.Second > two.second) {
            returnval.Add(Tuple.Create(one.first, one.Second);
        } else if ( two.First < one.irst && two.Second > one.Second) {
            returnval.Add(Tuple.Create(two.first, two.Second);
        } else if (one.first < two.First && one.Second < two.Second && one.Second > two.First) {
            returnval.Add(Tuple.Create(one.first, two.Second);
        } else if (one.Second > two.First && one.Second < two.Second && one.Second > two.second) {
            returnval.Add(Tuple.Create(two.first, one.Second);
        } else {
            returnVal.Add(one);
            returnVal.Add(two);
        }
        return returnVal;
    }

}

// one ---- ---      ----        ----    ---
// two  --      ----   -----   ----     ------


























