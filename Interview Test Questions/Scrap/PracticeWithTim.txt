DataTable dt = new DataTable();
dt.Compute(that);


// G1->T->X->V->TAIL
//   H/  I/
// G2/  J/
//    G3/

//G1->T->X
///H->T->X
///J->I->X

//G1 -> 5
//G2 -> 6
//G3 -> 6


Node {
    Node next;
    val c;
}

Node findMergePoint(Node[] lists) {
List<int> size = new List<int>();
foreach (Node n in lists) {
    size.Add(0);
    while (true) {
        size.Last()++;
        if (n.next == null) break;
        n = n.next;
    }
}

// find min
int min = size[0];
size.foreach( x => {
    if (x < min) min = x;
};

//advance
int listPointer = 0;
size.foreach(x => {
    for(int i = x; i > min; i++) {
        lists[listPointer] = lists[ListPointer].next;
    }
    listPointer++;
};

for (int i = n; n >= 0; n--) {
    Node n = lists[0];
    bool match = true;
    foreach(Node node in lists) {
        if (n != node) match = !match;  
    }
    if (match) return n
    else {
        foreach(Node node in lists) {
            node = node.next;        
        }
    }
}
return null;
}

//"I like apples!" -> "apples! like I"
//"!selppa ekil I" -> "apples! like I"
//"!selppa" -> apples!
string reverseString(string words) {



    //string[] splitString = words.Split(' '); //O(n)
    //for(int i = 0; i < splitString.Length/ 2; i++) {
      //  string temp = splitString[i] + " "; //O(n)
       // splitString[i] = splitString[splitString.Length-1-i] + " ";
        //splitString[splitString.Length-1-i] = temp;
    //}
    //return splitString.ToString(); //O(n)
} 